JAVA:

Java is Platform Independent:
    Java uses both compiler and interpreter to execute a file, firstly Java uses a compiler to convert a Java file to a .class file known 
    as bytecode which is not ready to be executed thus Java uses interpreter to convert .class file into machine code which is then is 
    ready to be executable using the jvm (Java virtual machine). Java is interpreted inside jvm.

Interpreter vs Compiler:
    Interpreter uses an interpreter to interpret the code for example a javascript uses browser as an interpreter to run its code, while 
    running the javascript code it is executed line by line and after that it is shown on the browser whereas 
    In the case of a compiler Like C language code is first converted into .exe executable file and then that executable file consisting 
    of the machine code is run every time you run the code. You can even delete your .c file also.

JRE:
    JVM(Java Virtual Machine) is inside JRE(Java Runtime Environment), and JRE is inside JDK(Java Development Kit).

Memory inside JVM:
    There are 2 memories inside JVM
    1. Stack Memory: 
        A new Stack is called whenever a new Method is called inside a class. This stack consists of all the variables and there values 
        in them. Whenever we declare an object like Test obj=new Test() or a String s="", this is also stored on the class as obj is 
        also a reference variable, but its value stored is the address of the object that is created inside the heap memory.

    2. Heap Memory: 
        All the object are created inside the heap memory. The instance variables(variables that are declared inside a class but outside 
        a function) and the method declaration is also stored inside heap memory. Heap also has a separate space in it named as string 
        constraint pool where Strings are stores, String (as it is an object) being immutable and Dynamic memory, they are stored in 
        heap memory.

Real-life uses of various data structures:
    > Array
        Calendars and Timetables: Arrays are used to store dates and times in a structured manner.
        Image Processing: An array of pixels represents an image, making it easier to manipulate and analyze.

    > Linked List
        Music Playlists: Songs can be dynamically added or removed without the need for contiguous memory allocation.
        Web Browsing History: A linked list can represent the sequence of websites visited, enabling efficient navigation through the history.

    > Stack
        Undo/Redo Functionality: Applications like text editors use stacks to keep track of actions for undo and redo operations.
        Browser Navigation: The back and forward buttons in web browsers are managed using stacks to keep track of visited pages.

    > Queue
        Printer Queue: Print jobs are managed in a queue, where the first document sent to the printer is printed first (FIFO).
        Customer Service: Call centers use queues to manage incoming calls, ensuring that the first caller is served first.

    > Hash Table
        Databases: Hash tables are used to index data for quick retrieval.
        Caching: Web browsers and servers use hash tables to store frequently accessed data for faster access.

    > Tree
        File Systems: Directories and files are organized in a hierarchical tree structure for efficient navigation.
        Autocompletion: Search engines and text editors use trees to suggest words based on prefixes typed by the user.

    > Graph
        Social Networks: Users and their connections are represented as graphs to analyze relationships and interactions.
        Navigation Systems: Maps and GPS use graphs to find the shortest path between locations.

    > Heap
        Priority Queue: Task scheduling systems use heaps to manage tasks based on priority, ensuring high-priority tasks are executed first.
        Memory Management: Heaps are used in dynamic memory allocation to efficiently manage memory.

    > Trie
        Dictionary Implementation: Tries are used to store a large set of words for quick prefix-based search.
        IP Routing: Networking devices use tries to store routing tables for efficient IP address lookup.

    > Set
        Unique Data Storage: Sets are used to store unique items, such as unique identifiers in a database.
        Mathematical Operations: Operations like union, intersection, and difference can be efficiently performed on sets.

Time complexities for each data structure:
    > Array
        Access: O(1)
        Search: O(n)
        Insertion: O(n) (worst case, if inserting in the middle)
        Deletion: O(n) (worst case, if deleting from the middle)

    > Linked List
        Access: O(n)
        Search: O(n)
        Insertion: O(1) (if the position is known)
        Deletion: O(1) (if the position is known)

    > Stack
        Push: O(1)
        Pop: O(1)
        Peek/Top: O(1)
        Search: O(n)

    > Queue
        Enqueue: O(1)
        Dequeue: O(1)
        Peek/Front: O(1)
        Search: O(n)

    > Hash Table
        Insertion: O(1) (average case), O(n) (worst case, with many collisions)
        Deletion: O(1) (average case), O(n) (worst case, with many collisions)
        Search: O(1) (average case), O(n) (worst case, with many collisions)

    > Tree (Binary Search Tree - BST)
        Access: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Search: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Insertion: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Deletion: O(log n) (average case), O(n) (worst case, unbalanced tree)

    > Graph
        Access (using adjacency matrix): O(1)
        Access (using adjacency list): O(v + e) (v = number of vertices, e = number of edges)
        Search (DFS/BFS): O(v + e) (v = number of vertices, e = number of edges)
        Insertion (new edge): O(1) (adjacency list), O(v^2) (adjacency matrix)
        Deletion (existing edge): O(1) (adjacency list), O(v^2) (adjacency matrix)

    > Heap (Binary Heap)
        Insertion: O(log n)
        Deletion (remove max/min): O(log n)
        Search: O(n)

    > Trie
        Insertion: O(k) (k = length of the word)
        Deletion: O(k) (k = length of the word)
        Search: O(k) (k = length of the word)

    > Set (using Hash Set)
        Insertion: O(1) (average case), O(n) (worst case, with many collisions)
        Deletion: O(1) (average case), O(n) (worst case, with many collisions)
        Search: O(1) (average case), O(n) (worst case, with many collisions)

JDBC:
    Java DataBase Connectivity
    It is a process used to establish communication between Application and Database and manage Data.

    Steps:
    > Import JDBC Package
        import java.sql.*;

    > Load the Driver
        Class.forName("com.mysql.cj.jdbc.Driver");
    
    > Establish a Connection
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "root";
        String password = "password";
        Connection con = DriverManager.getConnection(url, username, password);

    > Create a Statement
        String query = "SELECT * FROM toys";
        ResultSet rs = stmt.executeQuery(query);

    > Process the Results
        while (rs.next()) {
            System.out.println(rs.getString("data"));
        }

    > Close the Connection
        rs.close();
        stmt.close();
        con.close();

    Complete Ex.
        import java.sql.*;

        public class Main {
            public static void main(String[] args) {
                try {
                    // 1. Load the driver
                    Class.forName("com.mysql.cj.jdbc.Driver");
                    
                    // 2. Establish a connection
                    String url = "jdbc:mysql://localhost:3306/mydatabase";
                    String username = "root";
                    String password = "password";
                    Connection con = DriverManager.getConnection(url, username, password);
                    
                    // 3. Create a statement
                    Statement stmt = con.createStatement();
                    
                    // 4. Execute a query
                    String query = "SELECT * FROM toys";
                    ResultSet rs = stmt.executeQuery(query);
                    
                    // 5. Process the results
                    while (rs.next()) {
                        System.out.println(rs.getString("toy_name"));
                    }
                    
                    // 6. Close the connection
                    rs.close();
                    stmt.close();
                    con.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

MultiThreading in JAVA:

Defination:
    Multithreading in Java is a feature that allows a program to run multiple threads simultaneously, making it more efficient and 
    responsive. Each thread can perform different tasks at the same time, helping to use the CPU better and improve the program’s 
    performance.

There are two main ways to implement multithreading:
    > Extending the Thread Class:
        You can create a new class that extends the Thread class and override its run() method.
        Ex.
        class A extends Thread
        {
            public void run()
            {
                System.out.print("a");
            }
        }
        public class Main
        {
            public static void main(String[] args) 
            {
                A a = new A();
                a.start(); // though we have to call run method we still write start because there is a start method in Thread class which internally calls run method.
            }
        }

    > Implementing the Runnable Interface:
        You can create a new class that implements the Runnable interface and provide the implementation for the run() method.
        Ex.
        class A implements Runnable
        {
            public void run()
            {
                System.out.print("a");
            }
        }
        public class Main
        {
            public static void main(String[] args) 
            {
                A a = new A(); // runnable itself does not have start() method so we need to create a Thread for it.
                Thread t = new Thread(a);
                t.start();
            }
        }

Thread Scheduler:
    In Java, the thread scheduler is a component of the Java Virtual Machine (JVM) that manages the execution of threads. It decides 
    which thread runs at any given time based on a scheduling algorithm. The scheduler's primary goal is to allocate CPU time to 
    threads in a fair and efficient manner. Java uses a preemptive scheduling model, meaning that the scheduler can interrupt a 
    running thread to give time to another thread, ensuring that all threads get a chance to execute.

Thread Lifecycle:

    > New (Born):
        The thread is created but not yet started.
        Example: Thread t = new Thread();\

    > Runnable (Ready to Run):
        The thread is ready to run and waiting for CPU time.
        Example: t.start(); - Starts the thread and moves it to the runnable state.

    > Running:
        The thread is currently executing.
        Example: Code within the run() method is executing.

    > Blocked:
        The thread is waiting to acquire a lock on an object.
        Example: synchronized(obj) {} - The thread is blocked until the lock is available.

    > Waiting:
        The thread is waiting indefinitely for another thread to perform a particular action.
        Example: t.wait(); - The thread waits until another thread calls notify() or notifyAll().

    > Terminated (Dead):
        The thread has completed its execution.
        Example: The run() method has finished executing, or t.stop() is called. 

Thread Related Methods:
    > sleep(long millis):
        Purpose: Pauses the current thread for a specified amount of time.
        Usage: Thread.sleep(1000); pauses the thread for 1000 milliseconds (1 second).
        Important: It’s a static method and can be called from any thread, but it can throw an InterruptedException.

    > join():
        Purpose: Waits for the thread to complete its execution.
        Usage: thread.join(); makes the current thread wait until thread finishes.
        Important: Useful for synchronizing threads, ensuring one thread completes before another continues.

    > suspend():
        Purpose: Suspends a thread’s execution.
        Usage: thread.suspend(); pauses the thread’s execution without releasing its resources.
        Important: Deprecated due to potential issues with deadlock and resource management. Use higher-level concurrency utilities instead.
    
    > resume():
        Purpose: Resumes a thread that was suspended.
        Usage: thread.resume(); continues the thread’s execution after a suspend().
        Important: Deprecated due to the issues associated with suspend(). Use wait() and notify() for thread coordination.

    > stop():
        Purpose: Terminates a thread immediately.
        Usage: thread.stop(); forcibly stops the thread.
        Important: Deprecated because it can leave shared resources in an inconsistent state. Prefer using interrupt() and handling thread termination more gracefully.

    > interrupt():
        Purpose: Requests the thread to stop its current operation.
        Usage: thread.interrupt(); sets the interrupt flag for the thread, which can be checked using Thread.interrupted().
        Important: Provides a safe way to signal a thread to stop what it’s doing, especially in long-running operations.

    > yield():
        Purpose: Hints to the thread scheduler that the current thread is willing to yield its current use of the CPU.
        Usage: Thread.yield(); may allow other threads of the same or higher priority to run.
        Important: It’s a hint, not a command; the actual behavior depends on the thread scheduler.

Synchronization:
    Synchronization in Java is a technique used to overcome difficulties arrised by multithreading by managing access to shared 
    resources by multiple threads, ensuring that only one thread can access a resource at a time. This prevents conflicts and ensures 
    that operations on shared data are performed consistently, avoiding errors and data corruption in a multi-threaded environment.

    This is classified in 2 Types:
    > Method Level:
        Method-level synchronization uses the synchronized keyword to lock an entire method, ensuring only one thread can execute it 
        on the same object at a time.
        Ex. 
            class A implements Runnable
            {
                int seat = 1;
                public void run()
                // public synchronized void run()
                {
                    if(seat >= 1)
                    {
                        String name = Thread.currentThread().getName();
                        System.out.println(name + " gets Seat");
                        seat--;
                    }
                    else
                    {
                    System.out.println("No seat is Empty"); 
                    }
                }
            }
            public class Main
            {
                public static void main(String[] args) 
                {
                    A a = new A();
                    
                    Thread t1 = new Thread(a);
                    Thread t2 = new Thread(a);
                    Thread t3 = new Thread(a);
                    
                    t1.setName("Amy");
                    t2.setName("Bob");
                    t3.setName("Cat");
                    
                    t1.start();
                    t2.start();
                    t3.start();
                }
            }

            // normal will give
            // Amy gets Seat
            // Cat gets Seat
            // Bob gets Seat

            // and synchronized will give
            // Amy gets Seat
            // No seat is Empty
            // No seat is Empty


    > Block Level(Better):
        Block-level synchronization uses the synchronized keyword within a method to lock only specific sections of code, allowing 
        finer control over synchronization.
        Ex.
            class A implements Runnable
            {
                int seat = 1;
                public void run()
                {
                    synchronized(this)
                    {
                        if(seat >= 1)
                        {
                            String name = Thread.currentThread().getName();
                            System.out.println(name + " gets Seat");
                            seat--;
                        }
                        else
                        {
                        System.out.println("No seat is Empty"); 
                        }
                    }
                }
            }
            public class Main
            {
                public static void main(String[] args) 
                {
                    A a = new A();
                    
                    Thread t1 = new Thread(a);
                    Thread t2 = new Thread(a);
                    Thread t3 = new Thread(a);
                    
                    t1.setName("Amy");
                    t2.setName("Bob");
                    t3.setName("Cat");
                    
                    t1.start();
                    t2.start();
                    t3.start();
                }
            }

            // normal will give
            // Amy gets Seat
            // Cat gets Seat
            // Bob gets Seat

            // and synchronized will give
            // Amy gets Seat
            // No seat is Empty
            // No seat is Empty

    Method-level synchronization is easier to implement but can lead to unnecessary blocking, while block-level synchronization is more 
    efficient as it locks only the necessary part of the code.


