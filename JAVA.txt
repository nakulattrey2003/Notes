JAVA:

Java is Platform Independent:
    Java uses both compiler and interpreter to execute a file, firstly Java uses a compiler to convert a Java file to a .class file known 
    as bytecode which is not ready to be executed thus Java uses interpreter to convert .class file into machine code which is then is 
    ready to be executable using the jvm (Java virtual machine). Java is interpreted inside jvm.

Interpreter vs Compiler:
    Interpreter uses an interpreter to interpret the code for example a javascript uses browser as an interpreter to run its code, while 
    running the javascript code it is executed line by line and after that it is shown on the browser whereas 
    In the case of a compiler Like C language code is first converted into .exe executable file and then that executable file consisting 
    of the machine code is run every time you run the code. You can even delete your .c file also.

JRE:
    JVM(Java Virtual Machine) is inside JRE(Java Runtime Environment), and JRE is inside JDK(Java Development Kit).

Memory inside JVM:
    There are 2 memories inside JVM
    1. Stack Memory: 
        A new Stack is called whenever a new Method is called inside a class. This stack consists of all the variables and there values 
        in them. Whenever we declare an object like Test obj=new Test() or a String s="", this is also stored on the class as obj is 
        also a reference variable, but its value stored is the address of the object that is created inside the heap memory.

    2. Heap Memory: 
        All the object are created inside the heap memory. The instance variables(variables that are declared inside a class but outside 
        a function) and the method declaration is also stored inside heap memory. Heap also has a separate space in it named as string 
        constraint pool where Strings are stores, String (as it is an object) being immutable and Dynamic memory, they are stored in 
        heap memory.

Real-life uses of various data structures:
    > Array
        Calendars and Timetables: Arrays are used to store dates and times in a structured manner.
        Image Processing: An array of pixels represents an image, making it easier to manipulate and analyze.

    > Linked List
        Music Playlists: Songs can be dynamically added or removed without the need for contiguous memory allocation.
        Web Browsing History: A linked list can represent the sequence of websites visited, enabling efficient navigation through the history.

    > Stack
        Undo/Redo Functionality: Applications like text editors use stacks to keep track of actions for undo and redo operations.
        Browser Navigation: The back and forward buttons in web browsers are managed using stacks to keep track of visited pages.

    > Queue
        Printer Queue: Print jobs are managed in a queue, where the first document sent to the printer is printed first (FIFO).
        Customer Service: Call centers use queues to manage incoming calls, ensuring that the first caller is served first.

    > Hash Table
        Databases: Hash tables are used to index data for quick retrieval.
        Caching: Web browsers and servers use hash tables to store frequently accessed data for faster access.

    > Tree
        File Systems: Directories and files are organized in a hierarchical tree structure for efficient navigation.
        Autocompletion: Search engines and text editors use trees to suggest words based on prefixes typed by the user.

    > Graph
        Social Networks: Users and their connections are represented as graphs to analyze relationships and interactions.
        Navigation Systems: Maps and GPS use graphs to find the shortest path between locations.

    > Heap
        Priority Queue: Task scheduling systems use heaps to manage tasks based on priority, ensuring high-priority tasks are executed first.
        Memory Management: Heaps are used in dynamic memory allocation to efficiently manage memory.

    > Trie
        Dictionary Implementation: Tries are used to store a large set of words for quick prefix-based search.
        IP Routing: Networking devices use tries to store routing tables for efficient IP address lookup.

    > Set
        Unique Data Storage: Sets are used to store unique items, such as unique identifiers in a database.
        Mathematical Operations: Operations like union, intersection, and difference can be efficiently performed on sets.

Time complexities for each data structure:
    > Array
        Access: O(1)
        Search: O(n)
        Insertion: O(n) (worst case, if inserting in the middle)
        Deletion: O(n) (worst case, if deleting from the middle)

    > Linked List
        Access: O(n)
        Search: O(n)
        Insertion: O(1) (if the position is known)
        Deletion: O(1) (if the position is known)

    > Stack
        Push: O(1)
        Pop: O(1)
        Peek/Top: O(1)
        Search: O(n)

    > Queue
        Enqueue: O(1)
        Dequeue: O(1)
        Peek/Front: O(1)
        Search: O(n)

    > Hash Table
        Insertion: O(1) (average case), O(n) (worst case, with many collisions)
        Deletion: O(1) (average case), O(n) (worst case, with many collisions)
        Search: O(1) (average case), O(n) (worst case, with many collisions)

    > Tree (Binary Search Tree - BST)
        Access: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Search: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Insertion: O(log n) (average case), O(n) (worst case, unbalanced tree)
        Deletion: O(log n) (average case), O(n) (worst case, unbalanced tree)

    > Graph
        Access (using adjacency matrix): O(1)
        Access (using adjacency list): O(v + e) (v = number of vertices, e = number of edges)
        Search (DFS/BFS): O(v + e) (v = number of vertices, e = number of edges)
        Insertion (new edge): O(1) (adjacency list), O(v^2) (adjacency matrix)
        Deletion (existing edge): O(1) (adjacency list), O(v^2) (adjacency matrix)

    > Heap (Binary Heap)
        Insertion: O(log n)
        Deletion (remove max/min): O(log n)
        Search: O(n)

    > Trie
        Insertion: O(k) (k = length of the word)
        Deletion: O(k) (k = length of the word)
        Search: O(k) (k = length of the word)

    > Set (using Hash Set)
        Insertion: O(1) (average case), O(n) (worst case, with many collisions)
        Deletion: O(1) (average case), O(n) (worst case, with many collisions)
        Search: O(1) (average case), O(n) (worst case, with many collisions)

JDBC:
    Java DataBase Connectivity
    It is a process used to establish communication between Application and Database and manage Data.

    Steps:
    > Import JDBC Package
        import java.sql.*;

    > Load the Driver
        Class.forName("com.mysql.cj.jdbc.Driver");
    
    > Establish a Connection
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "root";
        String password = "password";
        Connection con = DriverManager.getConnection(url, username, password);

    > Create a Statement
        String query = "SELECT * FROM toys";
        ResultSet rs = stmt.executeQuery(query);

    > Process the Results
        while (rs.next()) {
            System.out.println(rs.getString("data"));
        }

    > Close the Connection
        rs.close();
        stmt.close();
        con.close();

    Complete Ex.
        import java.sql.*;

        public class Main {
            public static void main(String[] args) {
                try {
                    // 1. Load the driver
                    Class.forName("com.mysql.cj.jdbc.Driver");
                    
                    // 2. Establish a connection
                    String url = "jdbc:mysql://localhost:3306/mydatabase";
                    String username = "root";
                    String password = "password";
                    Connection con = DriverManager.getConnection(url, username, password);
                    
                    // 3. Create a statement
                    Statement stmt = con.createStatement();
                    
                    // 4. Execute a query
                    String query = "SELECT * FROM toys";
                    ResultSet rs = stmt.executeQuery(query);
                    
                    // 5. Process the results
                    while (rs.next()) {
                        System.out.println(rs.getString("toy_name"));
                    }
                    
                    // 6. Close the connection
                    rs.close();
                    stmt.close();
                    con.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
