NodeJs

NodeJs Architecture:
    Request Handling: When a client makes a request to a Node.js server, the server accepts the request and places it in the event queue.

    Event Loop: The event loop is responsible for processing events in the event queue. It follows a FIFO (First In, First Out) approach, 
    meaning it processes events in the order they were added to the queue.

    Non-blocking and Blocking Operations:

    For non-blocking (asynchronous) operations, such as I/O operations, the event loop delegates the task to a separate thread (handled 
    by libuv in Node.js). When the operation completes, a callback is pushed into the event queue.
    For blocking (synchronous) operations, such as CPU-bound tasks, the event loop can't handle them directly. It delegates these 
    operations to the worker threads in the thread pool.
    Response Handling: When a task completes (either synchronous or asynchronous), its corresponding callback is placed back into the 
    event queue. The event loop then picks up this callback and processes it, which may involve sending a response to the client.

    Thread Pool: Node.js maintains a thread pool (managed by libuv) for handling blocking operations. It allows Node.js to execute CPU-bound tasks without blocking the event loop.

File handling in node:
    const fs = require("fs");

    // Sync ----->  it returns a value
    fs.writeFileSync("./number.txt", "+9198765432 number 1");

    const readingNumber = fs.readFileSync("./number.txt", "utf-8"); // creating
    console.log(readingNumber); // reading

    fs.appendFileSync("./number.txt", "new data is added in number 1");

    fs.copyFileSync("./number.txt", "./copy1.txt");
    fs.unlinkSync("./copy1.txt");

    // Async  -----> do not return a value(void type)
    fs.writeFile("./number2.txt", "+129876543 number 2", (err) => {});

    fs.readFile("./number2.txt", "utf-8", (err, readingNumber2) => {
    if (err) console.log("Error ", err);
    else console.log(readingNumber2);
    });

    fs.appendFile("./number2.txt", " new data is added in number 2", (err) => {});

creating a server and sending request to different pages:
    const http = require("http");

    const myServer = http.createServer((req, res) => {
    console.log("New Request created");
    if (req.url == "/") res.end("HomePage");
    else if (req.url == "/about") res.end("AboutPage");
    else res.end("Error 404");
    });

    myServer.listen(8000, () => {
    console.log("Port Started");
    });

    // res.end is used to send a message when a new user joined
    // we can also send some photo, video or even an html file

HTTP Request Methods:
    1. GET: When user wants to get some data from the server. Eg searching google.com
    2. POST: When user wants to send data to the server. Eg Filling Forms
    3. PUT: When user wants to upload data to the server. Eg Uploading a Picture
    4. PATCH: When user wants to change data of the server. Eg changing your name on facebook
    5. DELETE: When user wants to delete data from the server. Eg Deleting Account on Facebook.

Express:
    Express is a web application framework for Node.js that makes it easier to build web applications and APIs by providing a set of 
    features and tools. It simplifies tasks such as routing, handling HTTP requests and responses, managing middleware, and more. In 
    simple terms, Express allows developers to create web servers and define routes for handling different types of requests, making 
    it faster and easier to build powerful web applications.
    Express allows you to define routes that match specific URLs and HTTP methods (like GET, POST, PUT, DELETE).

    const express = require("express");

    const app = express();

    app.get("/", (req, res) => {
    return res.end("Home Page");
    });

    app.get("/about", (req, res) => {
    return res.end("Hello " + req.query.name + ", you are " + req.query.age);
    });

    app.listen(8000, () => {
    console.log(Server Started on port 8000);
    });

    // no need for the below and no need for importing http
    // const myServer = http.createServer(app);

    // myServer.listen(8000, () => {
    //   console.log("Port Started");
    // });

Status Codes:
    1xx Informational: Request received, continuing process.
        100: Continue
        101: Switching Protocols

    2xx Success: The request was successfully received, understood, and accepted.
        200: OK
        201: Created
        202: Accepted
        204: No Content

    3xx Redirection: Further action needs to be taken to complete the request.
        301: Moved Permanently
        302: Found (Previously "Moved Temporarily")
        304: Not Modified

    4xx Client Errors: The request contains bad syntax or cannot be fulfilled.
        400: Bad Request
        401: Unauthorized
        403: Forbidden
        404: Not Found

    5xx Server Errors: The server failed to fulfill an apparently valid request.
        500: Internal Server Error
        501: Not Implemented
        503: Service Unavailable

MongoDB Schema
    // for finding the url mongodb://127.0.0.1:27017 you have to open cmd and write mongosh then you will get the link, then you can write the name of the mongo Database yourself

    const mongoose = require("mongoose");
    // connecting to database
    mongoose
    .connect("mongodb://127.0.0.1:27017/DemoDB1")
    .then(() => console.log("MongoDB Connected".green.bold))
    .catch((err) => console.log("Error: ", err));

    // Schema
    const UserSchema = new mongoose.Schema(
    {
        firstName: { type: String, required: true },
        lastName: { type: String, required: false },
        email: { type: String, required: true, unique: true },
        job_title: { type: String },
        gender: { type: String },
    },
    { timestamps: true }
    );

    // Model
    const userModel = mongoose.model("userModel", UserSchema);

MVC:
    files in node js

    there will be 3 main folders in nodejs
    1. controllers
    2. models
    3. routes

    controllers will be having function which will controls all the things about the models,
    models will be the one responsible for showing the data on the routes,
    routes will handle all the routes,
    there is also views folder which contains all the ejs files which is used to write the form structure or anything that uses html.

CRUD:
    Certainly! Here's how you can perform all CRUD operations (Create, Read, Update, Delete) using Mongoose in Node.js:

    Create (C):
        Create a new document
        const newUser = await User.create({ fullName: "John Doe", email: "john@example.com" });

    Read (R):
        Read all documents:
        const allUsers = await User.find();

        Read a single document by ID:
        const user = await User.findById(userId);

        Read documents based on conditions:
        const users = await User.find({ age: { $gt: 18 } });

    Update (U):
        Update a single document by ID:
        await User.findByIdAndUpdate(userId, { age: 25 });

        Update multiple documents:
        await User.updateMany({ age: { $lt: 18 } }, { status: "minor" });

    Delete (D):
        Delete a single document by ID:
        await User.findByIdAndDelete(userId);

        Delete multiple documents:
        await User.deleteMany({ age: { $gte: 60 } });

    These examples demonstrate how to perform CRUD operations using Mongoose in a Node.js application connected to a MongoDB database.

Web Sockets:
    web sockets -- socket io
    1. when the send button is called socket.emit is called and userMessage is send to the backend.
    2. io.on("connection") is called and socket.on('userMessage') is called inside it which sends io.emit('message') which is send to the connections.
    3. then socket.on('message') this receives the message and displays it.
