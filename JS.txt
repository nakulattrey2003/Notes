JavaScript

var, let, const:
    var:
    Can be redeclared within the same scope.
    Can be initialized first and declared after (hoisting).
    Variables declared with var are present in the global scope if declared outside any function.
    Hoisting moves var declarations to the top of their containing function or script.
    Can be accessed as a property of the window object in a browser environment.
    Example: var a = 10;

    let:
    Cannot be redeclared within the same scope.
    Can be initialized first and declared after, but accessing before declaration results in a ReferenceError due to the Temporal Dead Zone (TDZ).
    Variables declared with let are block-scoped, meaning they exist only within the block in which they are declared, or within the function if declared inside a function.
    Hoisting moves let declarations to the top of their block scope, but they are not accessible until the actual declaration statement.
    Cannot be accessed as a property of the window object.
    Example: let a = 10;

    const:
    Cannot be redeclared within the same scope.
    Must be initialized at the time of declaration and cannot be initialized first and declared after.
    Variables declared with const are block-scoped, similar to let.
    Hoisting moves const declarations to the top of their block scope, but they are not accessible until the actual declaration statement.
    const variables are more strict than let as their value cannot be reassigned after initialization.
    Cannot be accessed as a property of the window object.
    Example: const a = 10;

Scopes:
    Outer Scope: When you define a variable outside of any function, it is said to be in the global scope. Variables declared in the global scope are accessible from anywhere in your code.

    Inner Scope: When you define a function inside another function, the inner function has access to variables declared in the outer function. This is because the inner function's scope includes the scope of the outer function. This relationship forms a chain of nested scopes, where each inner scope has access to variables from outer scopes.

    Lexical Analysis: During the lexical analysis phase of code execution, JavaScript determines the scope chain by looking at the physical placement of the code in the source file. This means that the visibility of variables is determined by their position in the code, regardless of where the functions are called during runtime.

    // Global scope
    const globalVar = 'I am in the global scope';

    function outerFunction() {
        // Outer scope
        const outerVar = 'I am in the outer scope';

        function innerFunction() {
            // Inner scope
            const innerVar = 'I am in the inner scope';

            console.log(globalVar); // Accessing globalVar from the outermost scope
            console.log(outerVar); // Accessing outerVar from the outer scope
            console.log(innerVar); // Accessing innerVar from the innermost scope
        }
        innerFunction(); // Call innerFunction from within outerFunction
    }

    outerFunction(); // Call outerFunction to start the execution

    When innerFunction is called from within outerFunction, it logs the values of globalVar, outerVar, and innerVar to the console, demonstrating lexical scope.

closure:
    In simple words it is a combination of function and its lexical scope.
    When an inner function is called inside an outer function with a variable in it, whenever the inner function is called anywhere in the code it still remembers its lexical scope and will return the value of the variable even if the outer function does not exist yet.

    function outer()
    {
        var a1=7; //(thala for a reason)
        let a2=10;
        const a3=13;
        function inner()
        {
            console.log(a1);
            console.log(a2);
            console.log(a3);
        }
        return inner;
    }

    const b = outer();  // it will return a function that we had taken in b function
    // ... thousands of lines of code ....
    b(); // output 7 10 13

    the outer function with variable 7 is returning an inner function which is taken in const b function and whenever we will call this b 
    function it will execute the inner function where there is console.log(a1) is there, but as the outer function is vanished after giving 
    return statement so there should be no variable a1 but still the inner function remembers its lexical scope(outer scope), this is known 
    as closure.

hiding or encapsulation:
    function Counter()
    {
        var a = 10;
        var temp = 0;
        return function inc() 
        {
        a++;
        console.log(a);
        }
        return function dec()
        {
            a--;
            console.log(a);
        }
    }
        
    const plus=Counter();
    const minus=Counter();

    plus();
    plus();
    minus();
    In this example, the Counter function defines a local variable a and returns an inner function inc(). This inner function inc() has 
    access to the outer function's variables (a and temp) due to closure, allowing it to increment the value of a and log it to the console. 
    However, the dec() function is defined but not returned, making it inaccessible from outside the Counter function.
    This example showcases how closures can be used to hide certain variables or functions within a scope, providing a way to encapsulate and 
    protect internal state or behavior

Types of Functions:
    First Class Function:
        > ability to use a function as a value 
        > can be passed into another function
        > can be returned out of another function

    Higher order function : 
        when we pass a function as a parameter to another function or we return a function from a function then the outer function is called 
        higher order function and inner function is called callback function.

    callback function: 
        when we pass a function as a parameter to another function or we return a function from a function then the outer function is called 
        higher order function and inner function is called callback function.

        In the given example area and circumference are normal function but when passed as logic in calculate they become callback function whereas calculate is a higher order function.

        const arr = [1, 2, 3, 4];

        const area = function (radius) {
        console.log(Math.PI * radius * radius);
        };

        const circumference = function (radius) {
        console.log(Math.floor(2 * Math.PI * radius));
        };

        const calculate = function (arr, logic) {
        const ans = [];
        for (var i = 0; i < arr.length; i++) {
            logic(arr[i]);
        }
        };

        calculate(arr, area);
        calculate(arr, circumference);

Promise:
    > an object representing the eventual completion or failure of an asynchronous operation.
    > it is an object which is initially undefined but gets value as soon as the async operation gets executed.
    > Placeholder which will be fulfilled over certain period of time
    > A Container for a future value

    in the normal function:
    > we do not have any gurantee if our given callback function will ever get executed or not,
    > how many times will it get executed or,
    > we do not have the control over the callback function,
    > anyone can edit or modify the data
    > helps in resolving callback hell or pyramid of doom

    in promise function:
    > gurantee that promise will call the callback function whenever it will get the value from the main function
    > it will only be called once,
    > it will have only 1 of the 3 values (rejected, pending, fulfilled)
    > we have the control over the callback function,
    > the object is immutable

    const cart = ["pants", "shirts", "kurta"];

    // normal way
    createOrder(cart, function(orderId){
        proceedToPay(orderId)
    })

    // promise way
    const promise = createOrder(cart);
    promise.then(function(orderId){
        proceedToPay(orderId)
    })

    getting data using promise:
        const users = fetch("https://api.github.com/users/nakulattrey2003");
        users
        .then(function (data) {
            return data.json();
        })
        .then(function (data) {
            console.log(data.name);
        })
        .catch(function (error) {
            console.log("Error");
        });

    creating a promise:
        const pr = new Promise((resolve, reject) => {
        resolve("Passes");
        });

        async function getData() {
        return pr;
        }

        const datapr = getData();
        datapr.then((i) => console.log(i));

async await:
    // await is always used in an async function and in front of a promise

    const pr = new Promise((resolve, reject) => {
    resolve("Passes");
    });

    // normal using function
    function getData() {
    pr.then((data) => console.log(data));
    }
    getData();

    // using async await
    async function getData2() {
    const data = await pr;
    console.log(data);
    }
    getData2();

    async await errors
        async function sol() 
        {
            try 
            {
                const fetchData = await fetch(
                "https://api.github.com/users/nakulattrey2003"
                );
                const json = await fetchData.json();
                console.log(json.avatar_url);
            } 
            catch (err) 
            {
                console.log(err);
            }
        }

        sol();

Promise API Types:
    These helps in we send more than one promises aps. These are the arrays which take all the promises calls and in response gives the array of responses.

    eg. p1 p2 p3 are 3 processes
        3  2  1 are time to complete them in seconds

    1. promise.all
        > if all the 3 processes are settled then result will be array of settled success.
        > suppose p2 fails then the it will show result with an error in 2 sec.
        > also called fast fail.

    2. promise.allSettled
        > if all the 3 processes are settled then result will be array of settled success.
        > if any one of the fails, it will still wait for all the processes to be settled and then it will show the respective array of fail or success.

    3. promise.race
        > it waits for the first process to be settled(success or failed), shows an array with that process.

    4. promise.any
        > it waits for the first process to be settled success, it will be returned with that process.
        > if all the 3 fails then it will gave us the "aggregate error"
        > also known as success seeking api.

Promise api calls example
    const p1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("P1 success"), 3000);
    // setTimeout(() => reject("P1 fails"), 3000);
    });

    const p2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("P2 success"), 1000);
    // setTimeout(() => reject("P2 fails"), 1000);
    });

    const p3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("P3 success"), 2000);
    // setTimeout(() => reject("P3 fails"), 2000);
    });

    Promise.all([p1, p2, p3])
    .then((res) => {
        console.log(res);
    })
    .catch((err) => {
        console.error(err);
    });

    Promise.allSettled([p1, p2, p3])
    .then((res) => {
        console.log(res);
    })
    .catch((err) => {
        console.error(err);
    });

    Promise.race([p1, p2, p3])
    .then((res) => {
        console.log(res);
    })
    .catch((err) => {
        console.error(err);
    });

    Promise.any([p1, p2, p3])
    .then((res) => {
        console.log(res);
    })
    .catch((err) => {
        console.error(err);
    });

map & filter:
    const arr=[1,2,3,4,5,6];

    const ans1 = arr.map((x) => x*2); // used to transform the value
    const ans2 = arr.filter((x) => x > 2); // used to fiterout the value

    console.log("ans1: " + ans1);
    console.log("ans2: " + ans2);
